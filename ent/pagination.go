// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-message-center/ent/emaillog"
	"github.com/suyuan32/simple-admin-message-center/ent/emailprovider"
	"github.com/suyuan32/simple-admin-message-center/ent/smslog"
	"github.com/suyuan32/simple-admin-message-center/ent/smsprovider"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type EmailLogPager struct {
	Order  emaillog.OrderOption
	Filter func(*EmailLogQuery) (*EmailLogQuery, error)
}

// EmailLogPaginateOption enables pagination customization.
type EmailLogPaginateOption func(*EmailLogPager)

// DefaultEmailLogOrder is the default ordering of EmailLog.
var DefaultEmailLogOrder = Desc(emaillog.FieldID)

func newEmailLogPager(opts []EmailLogPaginateOption) (*EmailLogPager, error) {
	pager := &EmailLogPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultEmailLogOrder
	}
	return pager, nil
}

func (p *EmailLogPager) ApplyFilter(query *EmailLogQuery) (*EmailLogQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// EmailLogPageList is EmailLog PageList result.
type EmailLogPageList struct {
	List        []*EmailLog  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (el *EmailLogQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...EmailLogPaginateOption,
) (*EmailLogPageList, error) {

	pager, err := newEmailLogPager(opts)
	if err != nil {
		return nil, err
	}

	if el, err = pager.ApplyFilter(el); err != nil {
		return nil, err
	}

	ret := &EmailLogPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := el.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		el = el.Order(pager.Order)
	} else {
		el = el.Order(DefaultEmailLogOrder)
	}

	el = el.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := el.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type EmailProviderPager struct {
	Order  emailprovider.OrderOption
	Filter func(*EmailProviderQuery) (*EmailProviderQuery, error)
}

// EmailProviderPaginateOption enables pagination customization.
type EmailProviderPaginateOption func(*EmailProviderPager)

// DefaultEmailProviderOrder is the default ordering of EmailProvider.
var DefaultEmailProviderOrder = Desc(emailprovider.FieldID)

func newEmailProviderPager(opts []EmailProviderPaginateOption) (*EmailProviderPager, error) {
	pager := &EmailProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultEmailProviderOrder
	}
	return pager, nil
}

func (p *EmailProviderPager) ApplyFilter(query *EmailProviderQuery) (*EmailProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// EmailProviderPageList is EmailProvider PageList result.
type EmailProviderPageList struct {
	List        []*EmailProvider `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (ep *EmailProviderQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...EmailProviderPaginateOption,
) (*EmailProviderPageList, error) {

	pager, err := newEmailProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if ep, err = pager.ApplyFilter(ep); err != nil {
		return nil, err
	}

	ret := &EmailProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := ep.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		ep = ep.Order(pager.Order)
	} else {
		ep = ep.Order(DefaultEmailProviderOrder)
	}

	ep = ep.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := ep.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type SmsLogPager struct {
	Order  smslog.OrderOption
	Filter func(*SmsLogQuery) (*SmsLogQuery, error)
}

// SmsLogPaginateOption enables pagination customization.
type SmsLogPaginateOption func(*SmsLogPager)

// DefaultSmsLogOrder is the default ordering of SmsLog.
var DefaultSmsLogOrder = Desc(smslog.FieldID)

func newSmsLogPager(opts []SmsLogPaginateOption) (*SmsLogPager, error) {
	pager := &SmsLogPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultSmsLogOrder
	}
	return pager, nil
}

func (p *SmsLogPager) ApplyFilter(query *SmsLogQuery) (*SmsLogQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// SmsLogPageList is SmsLog PageList result.
type SmsLogPageList struct {
	List        []*SmsLog    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (sl *SmsLogQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...SmsLogPaginateOption,
) (*SmsLogPageList, error) {

	pager, err := newSmsLogPager(opts)
	if err != nil {
		return nil, err
	}

	if sl, err = pager.ApplyFilter(sl); err != nil {
		return nil, err
	}

	ret := &SmsLogPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := sl.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		sl = sl.Order(pager.Order)
	} else {
		sl = sl.Order(DefaultSmsLogOrder)
	}

	sl = sl.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := sl.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type SmsProviderPager struct {
	Order  smsprovider.OrderOption
	Filter func(*SmsProviderQuery) (*SmsProviderQuery, error)
}

// SmsProviderPaginateOption enables pagination customization.
type SmsProviderPaginateOption func(*SmsProviderPager)

// DefaultSmsProviderOrder is the default ordering of SmsProvider.
var DefaultSmsProviderOrder = Desc(smsprovider.FieldID)

func newSmsProviderPager(opts []SmsProviderPaginateOption) (*SmsProviderPager, error) {
	pager := &SmsProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultSmsProviderOrder
	}
	return pager, nil
}

func (p *SmsProviderPager) ApplyFilter(query *SmsProviderQuery) (*SmsProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// SmsProviderPageList is SmsProvider PageList result.
type SmsProviderPageList struct {
	List        []*SmsProvider `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (sp *SmsProviderQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...SmsProviderPaginateOption,
) (*SmsProviderPageList, error) {

	pager, err := newSmsProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if sp, err = pager.ApplyFilter(sp); err != nil {
		return nil, err
	}

	ret := &SmsProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := sp.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		sp = sp.Order(pager.Order)
	} else {
		sp = sp.Order(DefaultSmsProviderOrder)
	}

	sp = sp.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := sp.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
